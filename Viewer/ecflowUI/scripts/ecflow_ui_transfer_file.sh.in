#!/bin/bash

#============================================================================
# Copyright 2009- ECMWF.
# This software is licensed under the terms of the Apache Licence version 2.0
# which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
# In applying this licence, ECMWF does not waive the privileges and immunities
# granted to it by virtue of its status as an intergovernmental organisation
# nor does it submit to any jurisdiction.
#============================================================================

set -e
#set -x #goes to stderr

#echo " arguments=$*"
#echo "shell=${SHELL}"

mode=
sourceFile=
remoteUid=${USER}
remoteHost=
targetFile=
proxyJump=
byteMode=
byteValue=
sshProxyJump=
sshOptions="-o StrictHostKeyChecking=no"
scpOptions="-o StrictHostKeyChecking=no"

while getopts m:s:u:h:t:j:b:v: flag
do
    case "${flag}" in
        m) mode=${OPTARG};;
        s) sourceFile=${OPTARG};;
        u) remoteUid=${OPTARG};;
        h) remoteHost=${OPTARG};;
        t) targetFile=${OPTARG};;
        j) proxyJump=${OPTARG};;
        b) byteMode=${OPTARG};;
        v) byteValue=${OPTARG};;
    esac
done

echo ""
echo "mode=$mode"
echo "sourceFile=$sourceFile"
echo "remoteUid=$remoteUid"
echo "remoteHost=$remoteHost"
echo "targetFile=$targetFile"
echo "proxyJump=$proxyJump"
echo "byteMode=$byteMode"
echo "byteValue=$byteValue"
echo "remoteUid=$remoteUid"
echo ""

if [[ $mode != "file" && $mode != "dir" ]] ; then
    echo "Error: invalid mode! Has to be \"file\" or \"dir\"" >&2
    exit 1
fi

if [[ $sourceFile == "" ]] ; then
    echo "Error: sourceFile is empty!" >&2
    exit 1
fi

if [[ $remoteHost == "" ]] ; then
    echo "Error: remoteHost is empty!" >&2
    exit 1
fi

if [[ $targetFile == "" ]] ; then
    echo "Error: targetFile is empty!" >&2
    exit 1
fi

if [[ $proxyJump == "" ]] ; then
    echo "Error: proxyJump is empty!" >&2
    exit 1
elif [[ $proxyJump == "__NOJUMP__" ]] ; then
    proxyJump=""
else
    sshProxyJump="-J ${proxyJump}"
    if [[ ${scpOptions} == "" ]] ; then
        echo "scpOptions cannot be empty!" >&2
        exit 1
    fi
    scpOptions="${scpOptions} -o ProxyJump=${proxyJump}"
fi

if [[ $mode == "file" ]] ; then
    if [[ $byteMode != "all" && $byteMode != "pos" &&  $byteMode != "last" ]] ; then
        echo "Error: invalid byteMode value! Allowed values are: \"all\", \"pos\" and \"last\"" >&2
        exit 1
    fi

    if [[ $byteValue == "" ]] ; then
        echo "Error: byteValue is empty!" >&2
        exit 1
    fi

    if [[ $byteValue -lt 0 ]] ; then
        echo "Error: byteValue (=${byteValue}) must be >=0!" >&2
        exit 1
    fi
fi

if [[ $remoteUid == "" ]] ; then
    echo "Error: remoteUid is empty!" >&2
    exit 1
fi

if [[ $remoteUid == "__USER__" ]]  ; then
    remoteUid=${USER}
fi

remoteUH="${remoteUid}@${remoteHost}"

# fetching a file
if [[ $mode == "file" ]] ; then
    
    # transfer the whole file
    if [[ $byteMode == "all" ]] ; then
        echo "transfer the whole file"
        (set -x; scp ${scpOptions} ${remoteUH}:${sourceFile} ${targetFile})

    # transfer from a given byte offset
    elif  [[ $byteMode == "pos" ]] ; then
        cmd=$(cat <<-END
            tail -c +$((${byteValue}+1)) ${sourceFile}
END
)       
        echo "transfer file from byte offset=${byteValue}"
        (set -x; ssh ${sshProxyJump} ${remoteUH} ${sshOptions} "${cmd}" > ${targetFile})
       
    #transfer the last bytes of the file
    elif [[ $byteMode == "last" ]] ; then
        cmd=$(cat <<-END
            sourceSize=\$(wc -c < ${sourceFile})
            if [[ \${sourceSize} -gt 0 && \${sourceSize} -le ${byteValue} ]] ; then 
                cat ${sourceFile}
            else
                tail -c ${byteValue} ${sourceFile}
            fi
END
)
        #printf 'cmd: %s\n' "${cmd}"
        echo "transfer last ${byteValue} bytes"
        (set -x; ssh ${sshProxyJump} ${remoteUH} ${sshOptions} "${cmd}" > ${targetFile})
    else
        echo "Invalid byteMode=${byteMode} option" >&2 
        exit 1
    fi
# fetching directory listing
else
    dirPath=$(dirname ${sourceFile})
    sourceName=$(basename ${sourceFile})
    echo "dirPath="$dirPath
    echo "sourceName="$sourceName
    pattern=$(echo $sourceName | cut -d '.' -f 1)".*"
   
    # the task here is to get the file modification date, file size in bytes
    # and file name for each file matching the pattern in the remote directory.
    # ls -l cannot be used here because apart from the parsing problems the 
    # modification date is not always complete (e.g. for dates older than 6 months).
    # Using stat is not an option either since it can have different options on
    # different unix systems
    cmd=$(cat <<-END
    cd ${dirPath}
    for f in \$(ls $pattern) ; do 
        if [[ ! -d "\$f" ]] ; then
            echo \$(date -r "\$f" +%s) \$( wc -c "\$f" | awk '{print \$1}' ) \$f
        fi
    done
END
)
    echo "get directory listing"
    (set -x; ssh ${sshProxyJump}  ${remoteUH} ${sshOptions} "${cmd}" > ${targetFile})
fi
