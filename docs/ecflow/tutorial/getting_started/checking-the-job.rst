.. index::
   single: checking-the-job
     
.. _checking-the-job:

Checking the job
=====================

In the previous section, we saw how a script was transformed into a job file.
If we try to run this job manually, it will fail.

.. code-block:: shell

    $HOME/course/test/t1.job0

This is is because ecflow_client commands embedded in the script/job can not communicate with the server. 
The port ECF_PORT was generated by the python script and would not typically correspond to the port of your server.
The ECF_PASSWD is used to detect zombies.  This was generated by the python script and not the server, hence the job will be treated like a zombie, in the case where the ECF_PORT matched.

.. note::

    When a job is generated by the server, it will never be with an extension '.job0'.   It is typically  't1.job1', 't1.job2', 't1.job3'. 
    
    The number at the end increments with each run of the job.

Regardless of how the job was generated, i.e. via python script or by the ecflow server,  we need a way of checking the job independent of ecFlow. This can be done by setting an environment variable:

.. code-block:: shell

    export NO_ECF=1
    $HOME/course/test/t1.job0

When NO_ECF is set, ecflow_client executable returns immediately with a return value of 0. (i.e. success). This lets you exercise your scripts/job independent of ecflow.

**What to do**

#. ``export NO_ECF=1``
#. run your job file ``$HOME/course/test/t1.job0``